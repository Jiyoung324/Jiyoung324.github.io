---
layout: single
title: 그리디 알고리즘 예제
date:   2020-04-16 00:43:22 +0900
author: Jiyoung
use_math: true
---

## 그리디 알고리즘 예제

### 문 제

개미 여러 마리가 길이가 lcm인 막대 위에 있다. 각 개미의 이동 속도는 모두 일정하며, 1cm/s이다. 개미가 막대의 마지막까지 걸어간다면, 개미는 그 즉시 떨어지게 된다. 또, 두 개미가 만나게 된다면, 방향을 반대로 바꾸어 걸어가게 된다.

가장 처음에 막대 상에서 개미의 위치를 알고 있다. 하지만, 개미가 어느 방향으로 움직이는 지는 알 수가 없다. 이때, 모든 개미가 땅으로 떨어질 때까지 가능한 시간 중 가장 빠른 시간과 느린 시간을 구하는 프로그램을 작성하시오.



### 입 력

첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스의 첫째 줄에는 막대의 길이와 개미의 수 n이 주어진다. 다음 n개 줄에는 숫자가 하나씩 주어지며, 이 숫자는 개미의 초기 위치를 나타낸다. 입력으로 주어지는 모든 수는 1,000,000보다 작거나 같으며, 공백으로 구분되어져 있다. 개미의 위치는 막대 왼쪽 끝에서부터 떨어진 거리이다.



### 출 력

각 테스트 케이스에 대해서, 두 숫자를 출력한다. 첫 번째 숫자는 개미가 모두 땅으로 떨어지는 가능한 시간 중 가장 빠른 시간, 두 번째 숫자는 가장 늦은 시간이다.



### 제 한

- 1 ≤ n ≤ 100000
- 1 ≤ l ≤ 1000000
- 개미의 위치는 정수
- 0 ≤ 개미의 위치 ≤ l





### 풀 이

그리디알고리즘의 모토인 **" 매 선택에서 지금 이 순간 당장 최적인 답을 선택하여 적합한 결과를 도출"** 을 토대로 접근한다.

먼저, 개미가 향하는 방향 과 만나면 반대 방향으로 간다는 조건 과 개미의 이동 속도 등 은 배제한 뒤, **개미의 위치를 중점**으로 살펴 보았다.



먼저, 개미가 모두 떨어지는 가장 빠른 시간은 개미가 있는 현재 위치에서 가장 가까운 끝으로 가는 경우이고 가장 느린 시간은 현재 위치에서 가장 먼 끝으로 가는 경우 이다.



막대기의 길이를 L 이라고 할 때,  막대기의 절반인 L/2 를 기준으로 

- **L/2 < (개미의 현재 위치)** 일 때, 

  개미는 중앙보다 오른쪽에 있으므로 (막대기의 길이 - 현재위치) 만큼 이동하는 것이 최소이동이고,

  현재 위치만큼 움직이는 것이 최대이동이다.

- **L/2  > (개미의 현재 위치)** 일  때,

  개미는 중앙보다 왼쪽에 있으므로 현재 위치만큼 이동할 때가 최소이동, 

  (막대기의 길이 - 현재위치) 만큼 이동하는 것이 최대 이동이다.



전체 개미가 떨어지는 시간을 구하는 것이기에 최소 이동 개미와 최대 이동 개미 모두 두 경우에서 소요된 시간이 가장 긴 시간이 총 걸린 시간이 된다.



예를 들어보자.

 3마리의 개미가 10cm 막대기에 2, 6, 7 의 위치에 있다고 가정한다.

1. 2cm 의 위치는 막대기의 중앙(5cm) 의 위치보다 작으므로 왼쪽 끝으로 떨어지는 경우가 최소 시간 이다.

   현재 위치에서 반대쪽으로 움직이는 경우 가장 많은 시간이 걸리고 이는 (막대기의 길이 - 현재 위치) 로 나타 낸다.

   즉, 첫번째 개미는 2cm 이동이 최소, 8cm 이동이 최대 

2. 6cm 의 위치의 개미는 4cm 이동이 최소, 6cm 이동이 최대

3. 7cm 의 위치의 개미는 3cm 이동이 최소, 7cm 이동이 최대



이를 코드로 나타내보자

```java
antMin = Math.min(loc[j] , l-loc[j]);
antMax = Math.max(loc[j] , l-loc[j]);
```



최소 이동은 현재 위치와 (막대기길이-현재위치)  중 값이 더 작은게 최소이동으로 시간은 빠르다.

최대 이동은 현재위치와 (막대기 길이 - 현재위치) 중 값이 더 큰 게 최대이동으로 시간은 느리다.



```java
min = Math.max(min,antMin); 
max = Math.max(max,antMax);
```

최소 이동 개미 중 가장 큰 값이  걸린 시간의 가장 빠른 시간되고,

최대 이동 개미 중 가장 큰 값이  걸린 시간의 가장 느린 시간이 된다.



전체 코드는 다음과 같다.

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int tc = sc.nextInt();

        for(int i = 0; i < tc; i++) {
            int l = sc.nextInt();
            int n = sc.nextInt();
            int[] loc = new int[n];
            int min = 0 ,max = 0;

            for(int j = 0; j < n; j++) {
                loc[j] = sc.nextInt();
                
                int antMin = Math.min(loc[j],l-loc[j]);
                int antMax = Math.max(loc[j],l-loc[j]);

                min = Math.max(min,antMin); 
                max = Math.max(max,antMax);
            }
            System.out.println(min+" "+max);

        }
    }
}
```



 

문제 출처 : https://www.acmicpc.net/problem/4307
